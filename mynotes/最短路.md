## Dijkstra 

> 注意：存在负边权时不可用。

### 实现方法：

1. 定义$ans[n]$，$ans[i]$代表到达$i$点的最小花费
   
2. 定义`bool`数组`visit`，代表是否来过这里

> 注意：这里的访问过，是指“以这个点为中心计算过”，而不是ans值被更新过

3. `ans[起点]=0`,其余的赋值为`inf`

4. 定义一个`cur`变量，`visit[cur]=1`（访问过），代表现在的位置，初始值为起点。

5. 列举所有与`cur`相联通的的点，将这些点的ans值更新：

    $ans[i] = min(ans[i], ans[cur] + edge.value)$

6. 列举所有没有过的的点，找到`ans`值最小的点，赋值给`cur`，`visit[cur]=1`（访问过）
7. 所有点都访问过（`visit[i] == 1`），程序结束。此时，`ans[i]`代表从起点到i的最短路径

### Code

```cpp
int ans[n], vis[n];
void dijkstra()
{
    int cur = s;
    dis[cur] = 0;
    // 所有点vis都为1 则结束 (7)
    while (vis[cur] == 0)
    {
        vis[cur] = 1;
        for (int i = head[cur]; i != 0; i = e[i].next)
        {
            int j = e[i].to;
            if (vis[j])
                continue;
          
            dis[j] = min(dis[j], dis[cur] + e[i].val);
        }
        int m = 2147483647;
        for (int i = 1; i <= n; i++)
        {
            if (vis[i])
                continue;
            if (dis[i] < m)
            {
                m = dis[i];
                cur = i;
            }
        }
    }
}
/*------------------ leap optimize -------------------*/
struct node
{
    int dis;
    int pos;
    bool operator<(const node &x) const
    {
        return x.dis < dis;
    }
};
std::priority_queue<node> q;

void dijkstra()
{
    for (int i = 0; i <= n; i++)
        dis[i] = 2147483647;

    dis[s] = 0;
    q.push({0, s});

    while (!q.empty())
    {
        node tmp = q.top();
        q.pop();
        int x = tmp.pos, d = tmp.dis;
        if (vis[x])   //
            continue; //
        vis[x] = 1;   //
        for (int i = head[x]; i; i = e[i].next)
        {
            int y = e[i].to;
            if (dis[y] > dis[x] + e[i].val)
            {
                dis[y] = dis[x] + e[i].val;
                if (!vis[y])
                    q.push({dis[y], y});
            }
        }
    }
}
```

