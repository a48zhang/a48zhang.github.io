<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法竞赛资料收藏</title>
    <link href="/2023/08/03/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%94%B6%E8%97%8F/"/>
    <url>/2023/08/03/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%96%99%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="黑魔法"><a href="#黑魔法" class="headerlink" title="黑魔法"></a>黑魔法</h1><p><a href="https://www.cnblogs.com/Stellar-JUE/p/15412474.html">基于<code>fread</code>的快读</a></p><p><a href="https://www.luogu.com.cn/blog/encore/io-you-hua-nei-suo-shi">浅谈C++ IO优化——读优输优方法集锦</a></p><p><a href="https://codeforces.com/blog/entry/62393"><code>unordered_map</code>的hack与优化（英文）</a></p><p><a href="https://www.zhihu.com/question/292283275/answer/484871888"><code>SPFA</code>的hack与优化</a></p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p><a href="https://www.luogu.com.cn/blog/xht37/er-fen-tu-yu-wang-lao-liu">二分图与网络流</a></p>]]></content>
    
    
    <categories>
      
      <category>Competitive programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manacher回文串算法</title>
    <link href="/2023/07/12/Manacher%E5%9B%9E%E6%96%87%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/12/Manacher%E5%9B%9E%E6%96%87%E4%B8%B2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><code>Manacher</code>: $O(n)$的寻找回文串。</p><h1 id="P3805【模板】manacher-算法"><a href="#P3805【模板】manacher-算法" class="headerlink" title="P3805【模板】manacher 算法"></a><a href="https://www.luogu.com.cn/problem/P3805">P3805【模板】manacher 算法</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个只由小写英文字符 $\texttt a,\texttt b,\texttt c,\ldots\texttt y,\texttt z$ 组成的字符串 $S$ ,求 $S$ 中最长回文串的长度 。</p><p>字符串长度为 $n$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行小写英文字符 $\texttt a,\texttt b,\texttt c,\cdots,\texttt y,\texttt z$ 组成的字符串 $S$。$1\le n\le 1.1\times 10^7$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aaa</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>在原字符串的每个字符用一个<strong>字符集中不存在的字符</strong>隔开。</p><p>比如，对于一个由<code>a</code>到<code>z</code>的字符组成的串 <code>aabbbaa</code> -&gt; <code>|a|a|b|b|b|a|b|</code></p><p>这样做是为了使每个回文串都能找到<strong>对称中心</strong>。</p><p>对于一个长度为偶数的字符串 <code>aaaa</code> 他的对称中心在2和3之间。如果插入字符，<code>|a|a|a|a|</code> ，第5个字符就是他的中心。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>定义<code>p[i]</code>为每个字符的回文半径。同时记录一个mid，一个r，分别代表<strong>已经确定的右侧最靠右的回文串的对称中心和右边界</strong>。</p><p>对于第 <code>i</code> 个字符：</p><ul><li>如果 <code>i &lt;= r</code>，<code>p[i] = min(p[m * 2 - i], r - i + 1)</code> <ul><li><p><code>p[m * 2 - i]</code> 是与 <code>i</code> 关于点 <code>m</code> 对称的点。如果以这点为中心的最长回文串在 <code>[m-r, m]</code>范围内，<code>p[i]</code>显然也会具有这样一个回文串。</p></li><li><p>如果以这点为中心的最长回文串超出了 <code>[m - r, m]</code>范围，至少在 <code>[m - r, m]</code>范围内的回文串是有效的，可以被传递给<code>p[i]</code>。</p></li></ul></li><li>否则 <code>p[i] = 1</code>。</li></ul><p>随后暴力计算<code>p[i]</code>。</p><p>该字符串中的最长字串为：<code>max(p[i]) - 1</code>。<code>p[i]</code> 中计入了额外的分隔符，数目与回文中心的另一端等长，也就相当于回文串的长度。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-comment">// !!! N = n * 2, because you need to insert &#x27;#&#x27; !!!</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e7</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(A, B) ((A &gt; B) ? B : A)</span><br><span class="hljs-comment">// p[i]: range of the palindrome i-centered. </span><br><span class="hljs-type">int</span> p[N];<br><span class="hljs-comment">// s: the string.</span><br><span class="hljs-type">char</span> s[N] = <span class="hljs-string">&quot;@#&quot;</span>;<br><span class="hljs-comment">// l: length of s.</span><br><span class="hljs-type">int</span> l = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> tmp = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (tmp &gt; <span class="hljs-string">&#x27;z&#x27;</span> || tmp &lt; <span class="hljs-string">&#x27;a&#x27;</span>)<br>        tmp = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (tmp &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; tmp &gt;= <span class="hljs-string">&#x27;a&#x27;</span>)<br>        s[l++] = tmp, s[l++] = <span class="hljs-string">&#x27;#&#x27;</span>, tmp = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-comment">/*&lt;--- input &amp; preparation ---&gt;*/</span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++)<br>    &#123;<br>        <span class="hljs-comment">// evaluate p[i]</span><br>        <span class="hljs-keyword">if</span> (i &lt;= r)<br>            p[i] = <span class="hljs-built_in">min</span>(p[m * <span class="hljs-number">2</span> - i], r - i + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>            p[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// brute force!</span><br>        <span class="hljs-keyword">while</span> (s[i - p[i]] == s[i + p[i]])<br>            ++p[i];<br>        <span class="hljs-comment">// maintain m, r</span><br>        <span class="hljs-keyword">if</span> (i + p[i] &gt; r)<br>        &#123;<br>            r = i + p[i] - <span class="hljs-number">1</span>;<br>            m = i;<br>        &#125;<br>        <span class="hljs-comment">// find the longest p[i]</span><br>        <span class="hljs-keyword">if</span> (p[i] &gt; ans)<br>            ans = p[i]; <br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Competitive programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的编译期计算</title>
    <link href="/2023/06/25/C-%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97/"/>
    <url>/2023/06/25/C-%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>编译期运算就是指在编译阶段由编译器所进行的运算，不占用运行期时间，有时也称模版元编程。</p><p>提示：<code>constexpr</code>在C++11被引入。建议把编译器版本开的尽可能高。</p><h1 id="编译期常量"><a href="#编译期常量" class="headerlink" title="编译期常量"></a>编译期常量</h1><p>编译器的一些工作，如为数组分配空间、模板特化等，依赖于一些特定的参数（数组大小，模板元素类型）才能完成。很显然的，你不能像在运行期那样轻易的向程序中传入参数，而是需要用一些常量与变量进行运算。</p><p><strong>字面量</strong>是编译期常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">114514</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; b;<br></code></pre></td></tr></table></figure><p><strong><code>constexpr</code>变量</strong>可以被用作编译期常量。</p><p><strong><code>constexpr</code>变量</strong>必须满足下列要求：</p><ul><li>它的类型必须是<a href="https://zh.cppreference.com/w/cpp/named_req/LiteralType"><em>字面类型</em> <em>(LiteralType)</em> </a>。</li><li>它必须立即被初始化。</li><li>它的初始化包括所有隐式转换、构造函数调用等的<a href="https://zh.cppreference.com/w/cpp/language/eval_order">全表达式</a>必须是<a href="https://zh.cppreference.com/w/cpp/language/constant_expression">常量表达式</a></li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="编译期计算素数表"><a href="#编译期计算素数表" class="headerlink" title="编译期计算素数表"></a>编译期计算素数表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">get_state</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">constexpr</span> std::array&lt;<span class="hljs-type">int</span>, N&gt; is_not_prime = []() &#123;<br>        std::array&lt;<span class="hljs-type">int</span>, N&gt; is_not_prime&#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!is_not_prime[i])<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; N; j += i)<br>                &#123;<br>                    is_not_prime[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> is_not_prime;<br>    &#125;();<br><br>    <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> M = [is_not_prime]() &#123;<br>        std::<span class="hljs-type">size_t</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">2</span>; i &lt; N; ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!is_not_prime[i])<br>            &#123;<br>                ++cnt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;();<br><br>    std::array&lt;<span class="hljs-type">int</span>, M&gt; state&#123;&#125;;<br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!is_not_prime[i])<br>        &#123;<br>            state[j++] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> state = <span class="hljs-built_in">get_state</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:state)<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL学习笔记</title>
    <link href="/2023/05/25/C-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/25/C-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是STL"><a href="#什么是STL" class="headerlink" title="什么是STL"></a>什么是STL</h1><p>C++ Standard Template Library (STL)，即C++ 标准模板库，是 C++ 标准库的一部分。</p><p>其包括六大组件：</p><ul><li>容器（Containers）</li><li>算法（Algorithm）</li><li>迭代器（Iterators）</li><li>适配器（Adapters）</li><li>仿函数（Functors）</li><li>分配器（Allocators）</li></ul><h1 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h1><ul><li>分类<ul><li><p>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置</p><ul><li><strong>向量</strong>(<code>vector</code>) (顺序表)</li><li><strong>双端队列</strong>(<code>deque</code>) (顺序表)</li><li><strong>列表</strong>(<code>list</code>) (链表)</li><li><strong>单向列表</strong>(<code>forward_list</code>) (链表)</li><li><strong>数组</strong> <em>C++11</em>(<code>array</code>) (顺序表)</li></ul></li><li><p>关联式容器：二叉树（红黑树）结构，各元素之间没有严格的物理上的顺序关系.</p><ul><li><p><strong>集合</strong>(<code>set</code>) </p></li><li><p><strong>映射</strong>(<code>map</code>) <code>map</code>中所有元素都是<code>pair</code>，所有元素都会根据元素的键值自动排序</p></li><li><p><strong>多重映射</strong>(<code>multimap</code>) </p></li><li><p><strong>多重集合</strong>(<code>multiset</code>)</p></li></ul></li></ul></li></ul><h1 id="算法-Algorithms"><a href="#算法-Algorithms" class="headerlink" title="算法(Algorithms)"></a>算法(Algorithms)</h1><p><a href="https://zh.cppreference.com/w/cpp/algorithm"><code>#include &lt;algorithm&gt;</code></a> </p><ul><li><p>各种常用算法，如sort、find、copy、for_each等</p></li><li><p>分类</p><ul><li>质变算法：运算过程中会更改区间内的元素内容。如拷贝、替换、删除等</li><li>非质变算法：运算过程中不会更改区间内的元素内容。例如查找、计数、遍历、寻找极值等。</li></ul><p>  <code>//To be continue...</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的异常处理</title>
    <link href="/2023/05/03/Golang%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2023/05/03/Golang%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><img src="/2023/05/03/Golang%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1683112281963.jpeg" class=""><p>你或许受够了丑陋的 <code>if  err != nil &#123;...&#125;</code>，那么来聊一聊不太常见的<code>defer</code>,<code>panic</code>,<code>recover()</code></p><h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h2><p>在函数结束之前执行指定的函数。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面是<code>_defer</code>结构的源代码。不细说，因为我也不大懂。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A _defer holds an entry on the list of deferred calls.</span><br><span class="hljs-comment">// If you add a field here, add code to clear it in deferProcStack.</span><br><span class="hljs-comment">// This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct</span><br><span class="hljs-comment">// and cmd/compile/internal/ssagen/ssa.go:(*state).call.</span><br><span class="hljs-comment">// Some defers will be allocated on the stack and some on the heap.</span><br><span class="hljs-comment">// All defers are logically part of the stack, so write barriers to</span><br><span class="hljs-comment">// initialize them are not required. All defers must be manually scanned,</span><br><span class="hljs-comment">// and for heap defers, marked.</span><br><span class="hljs-keyword">type</span> _defer <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// ...</span><br>    <br>sp        <span class="hljs-type">uintptr</span> <span class="hljs-comment">// sp at time of defer</span><br>pc        <span class="hljs-type">uintptr</span> <span class="hljs-comment">// pc at time of defer</span><br>fn        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>  <span class="hljs-comment">// can be nil for open-coded defers</span><br>_panic    *_panic <span class="hljs-comment">// panic that is running defer</span><br>link      *_defer <span class="hljs-comment">// next defer on G; can point to either heap or stack!</span><br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>defer chain 是一条单向链表（看上面的 <code>link</code>）。很多文章说<code>defer</code>这里是一个<strong>栈</strong>，其实我们在聊同一件事。</p><pre class="mermaid">graph LRA[goroutine]B[defer func 3]C[defer func 2]D[defer func 1]A --> B --> C --> D</pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> f()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f()<br>&#125;<br><br><span class="hljs-comment">// runtime: goroutine stack exceeds 1000000000-byte limit</span><br><span class="hljs-comment">// runtime: sp=0xc0200f9380 stack=[0xc0200f8000, 0xc0400f8000]</span><br><span class="hljs-comment">// fatal error: stack overflow</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><code>defer</code> 语句中函数的参数是在 <code>defer</code> 语句声明时确定的。</li><li>当函数返回后，defer 声明的函数按照后进先出 (Last In First Out) 的顺序执行。</li><li>如果函数返回的是命名返回值（named return values），<code>defer</code> 声明的函数调用可以读写这个返回值。（见小练习！<code>foo3()</code>）</li><li><code>os.Exit()</code>会造成程序立即终止，此时<code>defer</code>不会被执行。</li></ol><h3 id="defer-与-return"><a href="#defer-与-return" class="headerlink" title="defer 与 return"></a>defer 与 return</h3><p>Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为<strong>给返回值赋值</strong>和<strong>RET</strong>两步。而<code>defer</code>语句执行的时机就<strong>在返回值赋值操作后，RET指令执行前</strong>。</p><pre class="mermaid">graph LRA[返回值 = x]B[执行defer]C[ret]A --> B --> C</pre><blockquote><p>可容纳 64 位（包括 <strong><code>__m64</code></strong> 类型）的标量返回值是通过 RAX 返回的。  非标量类型（包括浮点类型、双精度类型和向量类型，例如 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/m128?view=msvc-170"><code>__m128</code></a>、<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/m128i?view=msvc-170"><code>__m128i</code></a>、<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/m128d?view=msvc-170"><code>__m128d</code></a>）以 XMM0 的形式返回。 </p><p> [Microsoft Docs](<a href="https://learn.microsoft.com/zh-cn/cpp/build/x64-calling-convention?view=msvc-170#return-values">x64 调用约定 | Microsoft Learn</a>)</p></blockquote><h3 id="小练习！"><a href="#小练习！" class="headerlink" title="小练习！"></a>小练习！</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i++ &#125;()<br>fmt.Println(<span class="hljs-string">&quot;foo1:&quot;</span>, i)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i++ &#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i *<span class="hljs-type">int</span>)</span></span> &#123; *i++ &#125;(&amp;i)<br>fmt.Println(<span class="hljs-string">&quot;foo2:&quot;</span>, i)<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (x <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; x++ &#125;()<br>fmt.Println(<span class="hljs-string">&quot;foo3:&quot;</span>, x)<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;main: %d\n&quot;</span>, foo1(i))<br>fmt.Printf(<span class="hljs-string">&quot;main: %d\n&quot;</span>, foo2(i))<br>fmt.Printf(<span class="hljs-string">&quot;main: %d\n&quot;</span>, foo3(i))<br><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// foo1: 2</span><br><span class="hljs-comment">// main: 2</span><br><span class="hljs-comment">// foo2: 1</span><br><span class="hljs-comment">// main: 1</span><br><span class="hljs-comment">// foo3: 0</span><br><span class="hljs-comment">// main: 2</span><br><br><span class="hljs-comment">// Why?</span><br><br></code></pre></td></tr></table></figure><blockquote><p>提示：你可能需要了解<strong>命名返回值函数</strong>。</p></blockquote><h3 id="defer的用途"><a href="#defer的用途" class="headerlink" title="defer的用途"></a><code>defer</code>的用途</h3><ul><li>释放资源（数据库连接，文件句柄等）</li><li>释放<strong>读写锁</strong></li><li>视情况修改返回值</li><li>执行<code>recover()</code></li></ul><h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><p><code>panic()</code>会立即造成一个运行时错误。如果这个错误没有被捕获，程序会中止。十分显然的，defer语句会在程序中止前运行。</p><p>产生<strong>运行时</strong>错误意味着某个 <code>goroutine</code> 可以直接中止整个程序，所以你应该慎用。</p><blockquote><p>This is only an example but real library functions should avoid <code>panic</code>. If the problem can be masked or worked around, it’s always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak. —— Effective Go</p></blockquote><p>有时你的程序会遇到一些致命错误（比如，你连不上数据库），你可以继续运行，但没什么意义。这时，直接<code>panic()</code>或许比较合理。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/runtime2.go</span><br><br><span class="hljs-comment">// A _panic holds information about an active panic.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A _panic value must only ever live on the stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The argp and link fields are stack pointers, but don&#x27;t need special</span><br><span class="hljs-comment">// handling during stack growth: because they are pointer-typed and</span><br><span class="hljs-comment">// _panic values only live on the stack, regular stack pointer</span><br><span class="hljs-comment">// adjustment takes care of them.</span><br><span class="hljs-keyword">type</span> _panic <span class="hljs-keyword">struct</span> &#123;<br>argp      unsafe.Pointer <span class="hljs-comment">// pointer to arguments of deferred call run during panic; cannot move - known to liblink</span><br>arg       any            <span class="hljs-comment">// argument to panic</span><br>link      *_panic        <span class="hljs-comment">// link to earlier panic</span><br>pc        <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// where to return to in runtime if this panic is bypassed</span><br>sp        unsafe.Pointer <span class="hljs-comment">// where to return to in runtime if this panic is bypassed</span><br>recovered <span class="hljs-type">bool</span>           <span class="hljs-comment">// whether this panic is over</span><br>aborted   <span class="hljs-type">bool</span>           <span class="hljs-comment">// the panic was aborted</span><br>goexit    <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h2><p>解决眼下的<code>panic</code>并让正常控制流夺回控制权，无论<code>panic</code>是内部的（数组越界之类的）或是你蓄意 <code>panic()</code>造成的。</p><p>正常情况下，调用 recover 函数将返回 nil 且没有任何效果。只有当前 <code>goroutine</code> 为 <code>panicking</code> 状态，调用 <code>recover</code> 函数将捕获 <code>panic</code> 的值并且回到正常控制流。</p><p>特别的：</p><ul><li>对 <code>Goroutine Dead Lock</code>无效。实际上，所有的 <code>Fatal Error</code> 都无效。（<code>runtime</code> 都炸了，谁还能给你<code>recover</code>呢）</li><li>对子协程的<code>panic</code>无效。 <code>recover</code>只作用于当前<code>goroutine</code>的<code>_panic</code>链表。</li><li>对 <code>os.Exit()</code>无效。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>&#x2F;&#x2F; 这部分好像有问题，待改动</p><p>当 <code>panic</code> 被调用后，程序将立刻终止当前函数的执行，并开始自底向上的回溯 <code>goroutine</code> 的栈，运行<code>defer</code>函数。 若回溯到达 <code>goroutine</code> 栈的顶端，程序就会终止。调用 <code>recover</code> 将停止回溯过程，并返回传入 <code>panic</code> 的实参。由于在回溯时只有<code>defer</code>函数能够运行，因此 <code>recover</code> 只能在<code>defer</code>中才有效。</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li><code>defer</code>一定要在可能引发<code>panic</code>的<strong>语句之前定义</strong>。</li></ul><h2 id="goroutine-源代码节选"><a href="#goroutine-源代码节选" class="headerlink" title="goroutine 源代码节选"></a><code>goroutine</code> 源代码节选</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// ...</span><br><br>_panic    *_panic <span class="hljs-comment">// innermost panic - offset known to liblink</span><br>_defer    *_defer <span class="hljs-comment">// innermost defer</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://golang.google.cn/doc/effective_go#panic">Effective Go: Panic</a></p></li><li><p><a href="https://golang.google.cn/blog/defer-panic-and-recover">the Go Blog: Defer, Panic, and Recover</a></p></li><li><p><a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L414">go&#x2F;runtime2.go</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2023/05/02/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/05/02/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>能实现快速的区间查询、区间修改的数据结构。</p><p>实现区间修改、区间查询等操作的时间复杂度为 $O(\log N)$。</p><p>可以用来维护区间最大值、区间和、区间异或和等等。实际上，线段树的原理决定了其可以维护一切符合结合律的信息。（不符合结合律的运算？比方说，浮点数加法）</p><p>很长、不是很好写，如果没有区间修改需要可以写树状数组。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CF213769A"><a href="#CF213769A" class="headerlink" title="CF213769A"></a><a href="https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/A">CF213769A</a></h2><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5e5</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(X) ((X) &lt;&lt; 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(X) ((X) &lt;&lt; 1 | 1)</span><br><span class="hljs-comment">// &lt;------------------------------&gt;</span><br><span class="hljs-type">int</span> a[N]; <span class="hljs-comment">// 原始数据</span><br><span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r, v;<br>&#125; f[N &lt;&lt; <span class="hljs-number">2</span>]; <span class="hljs-comment">// 节点数需要乘4</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将指定操作向上（向根）传递</span><br>    f[pos].v = f[<span class="hljs-built_in">ls</span>(pos)].v + f[<span class="hljs-built_in">rs</span>(pos)].v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[pos].l = l, f[pos].r = r;<br>    <span class="hljs-keyword">if</span> (l == r)<br>    &#123;<br>        <span class="hljs-comment">// 这里是树的叶子节点，对他直接赋值</span><br>        f[pos].v = a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 对子树递归建树</span><br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-built_in">ls</span>(pos), l, mid);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">push_down</span>(pos);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>        <span class="hljs-keyword">return</span> f[pos].v;<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &gt; mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, r);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, r) + <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), l, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="普通的修改"><a href="#普通的修改" class="headerlink" title="普通的修改"></a>普通的修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>    &#123;<br>        f[pos].t += k;<br>        f[pos].v += k * (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &gt; mid)<br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), l, r, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, r, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, mid, k), <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r, k);<br>    <span class="hljs-built_in">push_up</span>(pos);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><p>当更新某一区间时，给维护该区间的节点打懒标记，不再把每个点都更新，以此实现优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    ll l, r, v, t; <span class="hljs-comment">// t 用于存储懒标记</span><br>&#125; f[N &lt;&lt; <span class="hljs-number">2</span>];<br><br></code></pre></td></tr></table></figure><p><code>push_down()</code>维护懒标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!f[pos].t)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 向下传递懒标记</span><br>    f[<span class="hljs-built_in">ls</span>(pos)].t += f[pos].t;<br>    f[<span class="hljs-built_in">rs</span>(pos)].t += f[pos].t;<br>    <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 处理懒标记</span><br>    <span class="hljs-comment">// 值 += 懒标记值 * 节点数</span><br>    f[<span class="hljs-built_in">ls</span>(pos)].v += f[pos].t * (mid - f[<span class="hljs-built_in">ls</span>(pos)].l + <span class="hljs-number">1</span>); <br>    f[<span class="hljs-built_in">rs</span>(pos)].v += f[pos].t * (f[<span class="hljs-built_in">rs</span>(pos)].r - mid);<br>    <span class="hljs-comment">// 去掉懒标记 因为已经传下去了</span><br>    f[pos].t = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, ll k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>    &#123;<br>        <span class="hljs-comment">// 更新只与现在的节点有关</span><br>        f[pos].t += k; <span class="hljs-comment">// 更新懒标记</span><br>        f[pos].v += k * (r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(pos); <span class="hljs-comment">// 注意</span><br>    <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &gt; mid)<br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), l, r, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, r, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, mid, k), <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r, k);<br>    <span class="hljs-built_in">push_up</span>(pos);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">push_down</span>(pos); <span class="hljs-comment">// 注意</span><br>    <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>        <span class="hljs-keyword">return</span> f[pos].v;<br>    <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &gt; mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), l, r);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, r);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, mid) + <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><p>默认维护的是区间和。构造函数接受两个参数，原始数组大小和原始数组（long long）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// modify here</span><br>        f[pos].v = f[<span class="hljs-built_in">ls</span>(pos)].v + f[<span class="hljs-built_in">rs</span>(pos)].v;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> pos)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!f[pos].t)<br>            <span class="hljs-keyword">return</span>;<br>        f[<span class="hljs-built_in">ls</span>(pos)].t += f[pos].t;<br>        f[<span class="hljs-built_in">rs</span>(pos)].t += f[pos].t;<br>        <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>        f[<span class="hljs-built_in">ls</span>(pos)].v += f[pos].t * (mid - f[<span class="hljs-built_in">ls</span>(pos)].l + <span class="hljs-number">1</span>); <span class="hljs-comment">// modify here</span><br>        f[<span class="hljs-built_in">rs</span>(pos)].v += f[pos].t * (f[<span class="hljs-built_in">rs</span>(pos)].r - mid);     <span class="hljs-comment">// modify here</span><br>        f[pos].t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">push_down</span>(pos);<br>        <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>            <span class="hljs-keyword">return</span> f[pos].v;<br>        <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &gt; mid)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), l, r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, r);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// modify here</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(pos), l, mid) + <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (f[pos].l &gt;= l &amp;&amp; f[pos].r &lt;= r)<br>        &#123;<br>            f[pos].t += k;<br>            f[pos].v += k * (r - l + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push_down</span>(pos);<br>        <span class="hljs-type">int</span> mid = (f[pos].l + f[pos].r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (l &gt; mid)<br>            <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), l, r, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt;= mid)<br>            <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, r, k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">update</span>(<span class="hljs-built_in">ls</span>(pos), l, mid, k), <span class="hljs-built_in">update</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r, k);<br>        <span class="hljs-built_in">push_up</span>(pos);<br>    &#125;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> l, r, v, t;<br>    &#125;;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a;<br><br>    <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> s, <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ori)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;size = s;<br>        a = ori;<br>        f = (node *)<span class="hljs-built_in">malloc</span>((s * <span class="hljs-number">4</span> + <span class="hljs-number">10</span>) * <span class="hljs-built_in">sizeof</span>(node));<br>        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, s);<br>    &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;<br>    node *f;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p &lt;&lt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        f[pos] = &#123;l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">if</span> (l == r)<br>        &#123;<br>            f[pos].v = a[l];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = ((l + r) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-built_in">ls</span>(pos), l, mid);<br>        <span class="hljs-built_in">build</span>(<span class="hljs-built_in">rs</span>(pos), mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">push_up</span>(pos);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一段古怪的代码</title>
    <link href="/2023/04/18/%E4%B8%80%E6%AE%B5%E5%8F%A4%E6%80%AA%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/04/18/%E4%B8%80%E6%AE%B5%E5%8F%A4%E6%80%AA%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>很久很久以前，我在互联网上的某个角落看到了这样一段代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *(*(*pfunc)(<span class="hljs-type">void</span> *(*)(<span class="hljs-type">int</span> *, <span class="hljs-type">float</span>), <span class="hljs-type">int</span>))(<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) = <br>        [](<span class="hljs-type">void</span> *(*)(<span class="hljs-type">int</span> *, <span class="hljs-type">float</span>), <span class="hljs-type">int</span>) -&gt; <span class="hljs-type">int</span> *(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) <br>    &#123; <span class="hljs-keyword">return</span> [](<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) -&gt; <span class="hljs-type">int</span> * &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; &#125;; &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该段代码可以在笔者的<code>Clang++ 16</code>上通过编译并正确运行。</p><p>（我看不懂，但我大受震撼.jpg）</p><p>为了复习我学过的指针、lambda函数知识，我决定试着解释这段代码。</p><hr><h1 id="What’s-happening"><a href="#What’s-happening" class="headerlink" title="What’s happening?"></a>What’s happening?</h1><p>前面的部分实在太复杂啦，也许我们可以从等号后面读起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 省略...</span><br>= [](<span class="hljs-type">void</span> *(*)(<span class="hljs-type">int</span> *, <span class="hljs-type">float</span>), <span class="hljs-type">int</span>) <br>    -&gt; <span class="hljs-type">int</span> *(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) &#123; <br>    <span class="hljs-keyword">return</span> [](<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) -&gt; <span class="hljs-type">int</span> * <br>    &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; &#125;; &#125;;<br></code></pre></td></tr></table></figure><p>这显然是一个lambda表达式，他的返回类型是 <code>int *(*)(int, double *)</code> —— 一个参数类型为<code>int, double *</code>，返回<code>int*</code>的函数指针。</p><h2 id="Lambda表达式是什么？"><a href="#Lambda表达式是什么？" class="headerlink" title="Lambda表达式是什么？"></a>Lambda表达式是什么？</h2><p>一种用来定义匿名函数的语法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-comment">/*捕获外部的变量*/</span>]<br>(<span class="hljs-comment">/*函数的参数*/</span>)<br>-&gt;<span class="hljs-comment">/*返回值类型。不填的话，编译器会帮你自动推导*/</span><br>&#123;<span class="hljs-comment">/*函数体部分*/</span>&#125;;<br></code></pre></td></tr></table></figure><h2 id="函数指针是什么？"><a href="#函数指针是什么？" class="headerlink" title="函数指针是什么？"></a>函数指针是什么？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明函数指针pFunc, 该函数接受两个int类型参数。</span><br><span class="hljs-built_in">int</span> (*pFunc)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><span class="hljs-comment">// 你可以像平常声明函数那样给参数起个名字。但没必要。</span><br><br><span class="hljs-comment">// 假设我们之前定义过了add函数（并且它刚好也接受两个int型参数）。</span><br><span class="hljs-type">int</span> pFunc = add;<br><span class="hljs-comment">// 函数名本身就是指向函数的指针</span><br><br><span class="hljs-comment">//调用！</span><br>(*pFunc)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// 加括号以避免符号运算顺序来捣乱</span><br></code></pre></td></tr></table></figure><p>再看看这个表达式吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 省略...</span><br>= [](<span class="hljs-type">void</span> *(*)(<span class="hljs-type">int</span> *, <span class="hljs-type">float</span>), <span class="hljs-type">int</span>) <br><span class="hljs-comment">// 参数</span><br><span class="hljs-comment">// 第一个参数是一个函数指针，接受参数(int *, float)，返回void *</span><br><span class="hljs-comment">// 第二个参数是一个int型变量</span><br>-&gt; <span class="hljs-type">int</span> *(*)(<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) <br><span class="hljs-comment">// 返回值类型</span><br><span class="hljs-comment">// 一个函数指针，接受参数(int, double *)，返回int *</span><br>&#123; <span class="hljs-keyword">return</span> [](<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *) -&gt; <span class="hljs-type">int</span> * &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; &#125;; &#125;;<br><span class="hljs-comment">// 函数体</span><br><span class="hljs-comment">// omg 怎么是lambda套娃</span><br><span class="hljs-comment">// 接受(int, double *)，返回 (int*)nullptr</span><br><span class="hljs-comment">// Tips: nullptr 的类型是 std::nullptr_t</span><br><span class="hljs-comment">// 它是一个特殊的类型，可以隐式地转换为任何指针类型，但不能转换为其他类型。</span><br></code></pre></td></tr></table></figure><h2 id="那么前面呢？"><a href="#那么前面呢？" class="headerlink" title="那么前面呢？"></a>那么前面呢？</h2><p>既然后面是一个lambda表达式，前面大概就是在声明函数指针吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *( <br>    <br>    *(*pfunc) ( <span class="hljs-type">void</span> *(*)(<span class="hljs-type">int</span> *, <span class="hljs-type">float</span>), <span class="hljs-type">int</span>)  <br>    <span class="hljs-comment">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br>    )<br>    (<span class="hljs-type">int</span>, <span class="hljs-type">double</span> *)<br>    <br>    <br></code></pre></td></tr></table></figure><p>是函数指针套娃，真难顶。</p><ul><li>外层：一个函数指针，接受 <code>(int, double *)</code>，返回 <code>int*</code>。</li><li>内层：一个指向函数指针<code>*pfunc</code>的指针。</li></ul><hr><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这段代码声明了<code>pfunc</code>，它指向一个接受<code>(void *(*)(int *, float), int)</code>  的函数，即后面那一大个lambda表达式。</p><p><code>pfunc</code>返回一个<code>int *(*)(int, double *)</code>型函数指针，即套在里面的小lambda。很显然，他的返回值是被转换成<code>int*</code>类型的<code>nullptr</code>。</p><p>人类怎么能写出这样的代码呢？</p>]]></content>
    
    
    <categories>
      
      <category>Programming Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/04/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/04/10/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h1><p><a href="https://oi-wiki.org//ds/dsu/">并查集</a>是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><p><strong>重要</strong> <strong>记得初始化</strong></p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\alpha(n))$ 。其中 $\alpha(n)$ 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>显然为 $O(n)$。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3375-【模板】并查集"><a href="#P3375-【模板】并查集" class="headerlink" title="P3375 【模板】并查集"></a><a href="https://www.luogu.com.cn/problem/P3367">P3375 【模板】并查集</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>如题，现在有一个并查集，你需要完成合并和查询操作。</p><p>对于 $100%$ 的数据，$1\le N \le 10^4$，$1\le M \le 2\times 10^5$，$1 \le X_i, Y_i \le N$，$Z_i \in { 1, 2 }$。 </p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。</p><p>接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。</p><p>当 $Z_i&#x3D;1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。</p><p>当 $Z_i&#x3D;2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出<br> <code>Y</code> ；否则输出 <code>N</code> 。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个 $Z_i&#x3D;2$ 的操作，都有一行输出，每行包含一个大写字母，为 <code>Y</code> 或者 <code>N</code> 。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">N</span><br>Y<br><span class="hljs-built_in">N</span><br>Y<br></code></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10009</span>;<br><span class="hljs-type">int</span> fa[N]; <span class="hljs-comment">// 存储每个节点的父节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 如果 fa[x] == x 则x是该树的根节点</span><br>    <span class="hljs-keyword">return</span> fa[x] == x ? x : <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 合并两棵树</span><br>    a = <span class="hljs-built_in">find</span>(a);<br>    b = <span class="hljs-built_in">find</span>(b);<br>    <span class="hljs-keyword">if</span> (a != b)<br>        fa[a] = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i; <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        <span class="hljs-type">int</span> z, x, y;<br>        cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (z == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">merge</span>(x, y);<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; ((<span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y)) ? <span class="hljs-string">&quot;Y&quot;</span> : <span class="hljs-string">&quot;N&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">/* Last modified: 23/07/12 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DSU</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> *f;<br>    <span class="hljs-type">int</span> size;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> size)<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(size &gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">this</span>-&gt;size = size;<br>        f = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size + <span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++)<br>            f[i] = i;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> f[x] == x ? x : (f[x] = <span class="hljs-built_in">find</span>(f[x]));<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> DSU::<span class="hljs-built_in">find</span>(x) != DSU::<span class="hljs-built_in">find</span>(y);<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> f[i];<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> fx = DSU::<span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> fy = DSU::<span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (fx != fy)<br>        &#123;<br>            f[fx] = fy;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形DP</title>
    <link href="/2023/04/10/%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2023/04/10/%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是树形DP"><a href="#什么是树形DP" class="headerlink" title="什么是树形DP"></a>什么是树形DP</h1><p>在树上跑DP。树的结构决定了树形DP常常使用递归的方式求解(<code>dfs</code>)。</p><h2 id="例题-P1352-没有上司的舞会"><a href="#例题-P1352-没有上司的舞会" class="headerlink" title="例题 P1352 没有上司的舞会"></a>例题 <a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>某大学有 $n$ 个职员，编号为 $1\ldots n$。</p><p>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。</p><p>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。</p><p>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行是一个整数 $n$。</p><p>第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。</p><p>第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行一个整数代表最大的快乐指数。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。</p><hr><p>尝试使用DP。</p><p>DP的两个条件：</p><ul><li>最优子结构：解由所有子树的最优解得到</li><li>无后效性：父节点的状态会影响子的状态，所以需要从叶子向根跑<code>dp</code> –&gt; <code>dfs</code></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[N][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// dp[i][j] - 以i为子树的解(j为1则选i,为0则不选)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    dp[x][<span class="hljs-number">1</span>] = r[x];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i; i = e[i].nxt)<br>    &#123;<br>        <span class="hljs-type">int</span> y = e[i].to;<br>        <span class="hljs-built_in">dfs</span>(y);<br>        dp[x][<span class="hljs-number">1</span>] += dp[y][<span class="hljs-number">0</span>];<br>        dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[y][<span class="hljs-number">1</span>], dp[y][<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ans = max(dp[s][0], dp[s][1])</span><br><span class="hljs-comment">// s为根节点</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Competitive Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo文档</title>
    <link href="/2023/04/09/hexo%E6%96%87%E6%A1%A3/"/>
    <url>/2023/04/09/hexo%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的泛型</title>
    <link href="/2023/04/09/generic/"/>
    <url>/2023/04/09/generic/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang中的泛型"><a href="#Golang中的泛型" class="headerlink" title="Golang中的泛型"></a>Golang中的泛型</h1><p>泛型函数是一种通用函数。它能接受不同类型的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">int64</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>对于函数<code>Foo</code>的参数<code>m map[K]V</code>：</p><ul><li>K 接受 comparable 泛型约束。comparable包括所有能进行比较的类型(<code>int8</code> ,<code>uint16</code>, <code>float32</code>, <code>string</code>…)。</li><li>V 接受<code>int64 | float64</code>泛型约束。V可以是两者中的任意一个。</li></ul><h2 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h2><h3 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h3><ul><li>实现对参数类型约束本身的代码复用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Number <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-type">int64</span> | <span class="hljs-type">float64</span> <span class="hljs-comment">// 可复用！</span><br>&#125;<br><br><span class="hljs-comment">// 为什么K的约束为comparable?</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Foo</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">Number</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span></span> V &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用参数类型提供的方法。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// From &quot;github.com/2023-Melting-Backend&quot;</span><br><span class="hljs-keyword">type</span> sth <span class="hljs-keyword">interface</span> &#123;<br>db.User | db.Template | db.ProposalInfo | db.Tag | db.Question | db.Game<br>TableName() <span class="hljs-type">string</span><br>GetKey() (<span class="hljs-type">string</span>, <span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UpdateSth</span>[<span class="hljs-title">T</span> <span class="hljs-title">sth</span>]<span class="hljs-params">(value T)</span></span> <span class="hljs-type">error</span> &#123;<br>pk, id := value.GetKey()<br>result := db.DB.Table(value.TableName()).Updates(value).Where(pk+<span class="hljs-string">&quot; = ?&quot;</span>, id)<br><span class="hljs-keyword">return</span> result.Error<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>如果不在接口中规定方法，编译会报错（即使约束中所有类型都实现了相关方法）。</p><img src="/2023/04/09/generic/1.png" class="" title="p1"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming Skills</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
